<!DOCTYPE html>
<html>
	<head>
		<title>Davidis's Kochbuch</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        
        <link rel="stylesheet" href="bootstrap-3.3.7-dist/css/bootstrap.min.css">
        <link rel="stylesheet" href="css/myStyle.css">
        
		<script src="js/jquery.min.js"></script>
		<script src="bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
	</head>
	
	<body style="padding-top:50px"> <!-- padding because otherwise navbar is over the beginning of the content -->
        <div id="navbar"></div>

		<div class="container-fluid">
            <div class="row myHeaderForSideWithMyLeftNavBar">
                <div class="col-md-12">
                    <h1><a href="#">Automatisches Anreichern mit <i>cueML</i></a></h1>
                </div>
            </div>

            <div class="row">
                <div class="col-md-2">
                    <div class="list-group panel myLeftNavBar">
                        <a href="#CRFPrototyp" class="list-group-item">CRF-based Prototyp</a>
                        <a data-toggle="collapse" class="list-group-item" href="#collapse1">Dictionary- and rule-based Prototyp<span class="caret"></span></a>
                        <div id="collapse1" class="collapse">
                            <a href="#DictBasedV01" class="list-group-item">Version 0.1</a>
                            <a href="#DictBasedV02" class="list-group-item">Version 0.2</a>
                        </div>
                    </div>
                </div>
                
                <div class="col-md-10">
                    <p>Inspiriert von dem vorherigen Abschnitt <a href="IEKochDomain.html">Information Extraction in der Koch-Domäne</a> stellen wir hier zwei verschiedene Prototypen vor, um aus den Zubereitungs-Anweisungen von unserem Kochbuch eine Zutatenliste zu extrahieren. Da wir auf keine vorhandene Semi-Struktur aufbauen können, ist ein Regular Expression-based Ansatz nicht möglich. Der CRF-based Prototyp ist sehr simpel. Uns ist bereits während der Konstruktion klar geworden, dass wir andere Voraussetzungen als <span cite="CRFNYT"></span> haben und dies daher nicht der richtige Ansatz für diese Arbeit ist.
                    </p>
                    
                    
                    <h2 id="CRFPrototyp" class="myAnchorWithFixedheader">CRF-based Prototyp</h2>
                    
                    <div class="row">
                        <div class="col-md-9">
                            <p>Unser CRF-based Prototyp ist in unserem Git-Repository unter dem Tag <a href="#">CRF-BasedPrototypeV0.1</a> zu finden. Er verwendet das <a href="http://www.swig.org/" title="Simplified Wrapper and Interface Generator">SWIG</a> Interface für <i>Python 3</i> von <a href="http://www.chokkan.org/software/crfsuite/">CRFsuite 0.12</a>.
                            </p>
                            
                            <p>Wie in <a href="IEKochDomain.html#CRFTheorie">CRF erklärt</a> erläutert, muss der Prototyp zuerst antrainiert werden. Abb. 1 zeigt einen kleinen Ausschnitt unserer Trainingsdaten für den CRF-based Prototypen. Nebenbei sei erwähnt, dass wir diese Anweisungen heute als eine Mehlschwitze bezeichnen würden.
                            </p>
                            
                            <p>Aus diesem kleinen Ausschnitt der Trainingsdaten sind bereits viele Problematiken ersichtlich, was später in der <a href="Evaluierung.html#CRFPrototyp" >Evaluierung dieses Prototypens</a> genauer erläutert wird. Daher haben wir zunächst einen simplen Prototypen gebaut, um zu schauen, ob CRF wirklich der richtige algorithmische Ansatz für unser Problem ist. Wie in Abb. 1 haben wir 10 Rezepte gelabelt. Mit <a href="#" title="Link zu den gelabelten Trainings-Rezepten">9</a> davon haben wir den CRF-based Prototypen trainiert und an dem <a href="#" title="Link zu dem gelabelten Test-Rezept">10.</a> getestet. Als features verwenden wir ausschließlich die Wort-Identität, sowie den Übergang von zwei benachtbarten Labels (B-Template). Für die Gewichte der features erlauben wir auch negative Werte.
                            </p>
                        </div>
                        
                        <div class="coll-md-3">
                                <figure myModal="images/AutomatischesAnreichrenCueML/AusschnittCRFTrainingsdaten.png">
                                    <figcaption>Abb. 1: Ausschnitt unserer CRF Trainingsdaten</figcaption>
                                    <img src="images/AutomatischesAnreichrenCueML/AusschnittCRFTrainingsdaten.png"/>
                                </figure>
                        </div>
                    
                    </div>
                    
                    
                    
                    
                    <h2 class="myAnchorWithFixedheader">Dictionary- and rule-based Prototyp</h2>
                    
                    <p>Nach dem wir zu der Erkenntnis gekommen sind, das <a href="Evaluierung.html#CRFPrototyp" title="Link zur Evaluierung">der vorherige Ansatz für diese Arbeit nicht zielführend ist</a>, stellen wir hier einen Dictionary- and rule-based Prototypen vor. Unsere Lemmatisierung für den dendictionary-based Teil baut auf <a href="https://github.com/miotto/treetagger-python">treetagger Version 1.0.1</a> auf.
                    </p>
                    
                    
                    <h3 id="DictBasedV01" class="myAnchorWithFixedheader">Version 0.1</h3>
                    
                    <p>Ein erster Prototyp ist in unserem Git-Repository unter dem Tag <a href="#">Dict-AndRule-BasedPrototypeV0.1</a> zu finden. Das Ziel dieses Prototypens ist erst einmal ausschließlich zu testen, ob das dictionary-based extrahieren unserer gesuchten Entities (Zutaten, Mengenangaben und Einheiten) funktioniert. Deswegen ist er nach dem Motto <i>quick and dirty</i> implementiert. Nach dem <a href="#Evaluierung.html/#DictBasedV01">die erste Evaluierung</a> positiv stimmt, haben wir den Prototypen quasi weggeworfen und in der folgeden Version 0.2 redesigned, wie es sich für einen quick and dirty Prototypen gehört. Daher wird hier auch nicht weiter auf Implementierung-Details sondern nur auf konzeptionelle Ideen eingegangen.
                    </p>
                    
                    <div class="row">
                        <div class="col-md-6">
                            <p>Abb. 2 zeigt den nahezu identischen Ablauf der dictionary-based Extraktion aus der <a href="IEKochDomain.html#DictBased" title="Information Extraction in der Koch-Domäne: Dictionary- and rule-based">vorherigen Sektion</a>. Die Überschrift eines Rezeptes wird als normaler Satz gesehen. Die Überschrift muss bei der Extraktion berücksichtigt werden, da manchmal eine Zutat nur in dieser erwähnt wird. Die Sätze splitten wir anhand von Satzzeichen. Um beispielsweise aus <i>Nach Nro. 2 wird [...]</i> nicht 2 Sätze zu machen, haben wir eine Menge von Abkürzungen, bei denen der Split wieder zusammengeführt wird.
                            </p>
                        </div>
                        
                        <div class="col-md-6">
                            <figure myModal="images/AutomatischesAnreichrenCueML/DictAndRuleBasedV0.1.png">
                                <figcaption>Abb. 2: Dictionary-based Extraktion der Entities</figcaption>
                                <img src="images/AutomatischesAnreichrenCueML/DictAndRuleBasedV0.1.png"/>
                            </figure>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-6">
                            <p>In Abb. 3 ist in einem ersten Schritt der Output eines Satzes von TreeTagger zu sehen. Neben dem Lemma gibt er zusätzlich ein Part-of-Speech-Tag (PoS) zu jedem Wort aus. Wie bei <i>Sellerie-</i> und <i>Scorzonerwurzeln</i> kann TreeTagger allerdings manchmal kein Lemma finden. Deswegen nehmen wir in einem ersten Schritt von jedem Wort ohne Lemma die Wort-Identität als Lemma. In einem zweiten Schritt versuchen wir bei jedem abgekürzten Wort die Endung zu finden. Abgekürzte Wörter haben das PoS "TRUNC" für truncation. Da alle abgekürzten Wörtern, an denen wir interessiert sind, Zutaten und somit Nomen sind, suchen wir das nächste Nomen im Satz, welche eine typisch abgekürzte Endung hat. der Prototyp testet, ob in dem Nomen "wurzel" bzw. "Wurzel" vorkommt, da dies die einzige Endung ist, die uns aufgefallen ist, dass sie von Frau Davidis regelmäßig abgekürzt wird. Ist dies der Fall, wird in dem abgekürzten Lemma das "-" durch die entsprechende Endung ersetzt.
                            </p>
                        </div>
                        
                        <div class="col-md-6">
                            <figure myModal="images/AutomatischesAnreichrenCueML/nachLemmatisierung.png">
                                <figcaption>Abb. 3: Nachbearbeitung von TreeTaggers Lemmatisierung</figcaption>
                                <img src="images/AutomatischesAnreichrenCueML/nachLemmatisierung.png"/>
                            </figure>
                        </div>
                    </div>

                    <div class="row">
                        <p>Was jetzt noch fehlt, sind die einzelnen Wörterbücher der zu extrahierten Entities:
                        </p>

                        <div style="padding-left: 2em;">
                            <p>In unserer <a href="DavidisesKochbuch/cueML/cueML_v0.5.rng">cueML-Schema Definition</a> ist eine Liste von erlaubten <b>Mengeneinheiten</b> (unit). Diese Liste von erlaubten Werten nehmen wir als Wörterbuch der Einheiten.
                            </p>
                        </div>
                        
                        <div style="padding-left: 2em;">
                            <p>Für die <b>Mengenangaben</b> verwenden wir kein echtes Wörterbuch sondern eine Funktion. Diese kriegt ein Lemma und liefert in folgenden drei Fällen ein positives Ergebnis:
                            </p>
                            <ul>
                                <li>Das Lemma ist eine Zahl.</li>
                                <li>Das Lemma hat die Form <i>Zahl-Zahl</i>.</li>
                                <li>Das Lemma ist in einer Menge von vordefinierter Mengen-Wörter <i>(ein, eine, einige, ...)</i>.</li>
                            </ul>
                        </div>
                        
                        <div style="padding-left: 2em;">
                            <div class="row">
                                <div class="col-md-6">
                                    <p>Wie in <a href="cueML.html">Domänen-spezifisches Vokabular cueML</a> erläutert, haben wir alle ausgezeichneten Zutaten mittels einer Liste von <i>ingredient</i>-Elementen an den BLS angeschlossen. Abb. 4 zeigt, wie wir aus diesen ein <b>Wörterbuch von Zutaten</b> extrahiert haben.
                                    </p>
                                </div>

                                <div class="col-md-6">
                                    <figure myModal="images/AutomatischesAnreichrenCueML/nachLemmatisierung.png">
                                        <figcaption>Abb. 3: Nachbearbeitung von TreeTaggers Lemmatisierung</figcaption>
                                        <img src="images/AutomatischesAnreichrenCueML/nachLemmatisierung.png"/>
                                    </figure>
                                </div>
                            </div>
                        </div>
                        
                    
                    </div>

                    
                    
                    
                    <h3 id="DictBasedV02" class="myAnchorWithFixedheader">Version 0.2</h3>
                </div>
                
            </div>
        </div>
		
        
        <script>activeTab = "DigitalEdition"</script>
        <script src="js/navbar.js"></script>
        <script src="js/figure2modal.js"></script>
        <script src="js/references.js"></script>
	</body>
</html> 